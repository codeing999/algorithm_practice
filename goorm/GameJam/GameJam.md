> https://level.goorm.io/exam/195692/gamejam/quiz/1


# 풀이 과정

일단 구름이란 사이트에서는 처음으로 문제를 풀어보는데,
input을 통해 데이터를 입력 받는 것이 특이했다.

테스트도 통과하고 제출도 5번케이스까지는 pass했지만 6번부터 time out으로 실패했다.
어디가 성능을 줄일 수 있는 부분일지 놓친 예외처리는 없는지 고민해보았지만
발생가능한 케이스가 그렇게 다양하진 않은 문제였어서 원인을 찾지 못하였다.

그러다가 이 문제의 해설지가 이미 나온 문제였다는걸 발견해서 해설지를 보고 비교해보았다.

> 해설지 링크 : https://goorm.notion.site/GameJam-Javascript-72ae0eb217724f7d9e4ca5f73b78f47a

문제 풀이의 접근 자체는 맞았다.
반복되는 부분을 함수화하고 간략화한 차이는 있지만 그렇다고 그러한 부분들이 성능 테스트 통과 여부를 결정할 것으로 생각되진 않았다.

그러다가 부분적으로 해설지에 있는 코드들로 교체해봤는데 원인을 발견하였다.

```js
let count = +board[gCoord.y][gCoord.x][0];
let command = board[gCoord.y][gCoord.x][1];
```

이게 내 기존 코드고 해설지를 참고하여 slice를 쓰는 방식으로 아래처럼 바꿨더니 바로 모든 케이스를 통과하였다.

```js
let count = +board[gCoord.y][gCoord.x].slice(0, -1);
let command = board[gCoord.y][gCoord.x].slice(-1);
```

이 슬라이스를 쓰느냐 인덱스로 접근하느냐가 왜 성능 차이를 보이는지는 현재로서는 검색해봐도 잘 나오지 않는다.

다만 GPT에게 물어보니
다음과 같이 답변해주었다.


첫 번째 코드는 board 배열의 [gCoord.y][gCoord.x] 위치에 있는 요소의 첫 번째 문자를 count 변수에 저장하고, 두 번째 문자를 command 변수에 저장하는 방식입니다.
두 번째 코드는 board 배열의 [gCoord.y][gCoord.x] 위치에 있는 요소를 slice() 메서드를 이용하여 가장 마지막 문자를 제외한 나머지 문자열을 count 변수에 저장하고, 가장 마지막 문자를 command 변수에 저장하는 방식입니다.

두 코드의 차이점은 문자열을 처리하는 방식에 있습니다. 성능 차이는 크게 없을 것으로 보입니다만, 두 번째 코드가 테스트를 통과한 이유는 다음과 같습니다:

- 메모리 절약: 첫 번째 코드는 [gCoord.y][gCoord.x] 요소를 두 번 추출하므로 같은 데이터를 두 번 가져오게 됩니다. 반면 두 번째 코드는 한 번 추출한 뒤에 slice()를 이용하여 필요한 부분만 잘라내어 사용하므로 중복된 데이터를 한 번만 가져올 수 있습니다.

- 자료 구조 변경: 성능이나 메모리 관리 측면에서 더 나은 방식으로 코드가 작동할 수 있도록, 자료 구조나 데이터 저장 방식을 변경한 가능성이 있습니다. 코드 내부 또는 호출하는 다른 부분에 변화가 있을 수 있으며, 이로 인해 두 코드의 성능 차이가 발생할 수 있습니다.

위의 두 가지 이유로 두 번째 코드가 성능 테스트를 통과한 것으로 보입니다. 그러나 성능 향상을 위해선 더 많은 컨텍스트나 코드를 분석해야 합니다.