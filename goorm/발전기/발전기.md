> https://level.goorm.io/exam/195694/%EB%B0%9C%EC%A0%84%EA%B8%B0/quiz/1

# 실패한 풀이

이번 문제도 제출했을 때 대다수는 pass했는데 일부를 fail한 것으로 보아 동작은 맞는데, 성능이 문제인 것으로 보였다.
재귀함수로 풀었는데, 아무래도 큐나 스택을 사용해서 풀어야 성능 문제가 해결될 것으로 짐작되었고
해설지가 나오면 그것을 참고하여 다시 풀어 볼 예정.

# 성공한 풀이

다음날 해설지를 보니, 역시나 큐나 스택을 사용하는 방식이 소개되었다.
그것들을 사용해서 bfs 혹은 dfs로 구현하는 방식이었는데 해설지에는 이 중에서
큐를 사용하여서 bfs를 통해 구현한 방식이 소개되었다.
이 문제의 경우 bfs든 dfs든 큰 차이가 없는 방식이라 생각되어서 나는
해설지와는 반대로 스택을 사용하여서 dfs로 구현해 보기로 하였다.

이번 해설지에서 가장 참고되었던 부분은 좌우위아래 한칸을 이동하는 부분을 구현함에 있어서 매우 짧은 코드로
이동하는 방식이었는데
dx/dy 기법이라고 소개되었다.

```js
const dx = [0, 0, 1, -1];
const dy = [1, -1, 0, 0];

for (let k = 0; k < 4; k++) {
  let nextR = currentR + dx[k];
  let nextC = currentC + dy[k];
  // 마을 안의 좌표인지 확인
  if (nextR >= 0 && nextR < N && nextC >= 0 && nextC < N) {
    // 집이 있으면서, 전기가 공급되고 있는지 확인
    if (matrix[nextR][nextC] === 1 && !visited[nextR][nextC]) {
      // 모든 조건을 만족하면 새로게 전기가 공급되는
      // 집이기 때문에, 탐색 후보에 추가한다.
      q.push([nextR, nextC]);
    }
  }
}
```

위의 두줄과 같이 길이 4짜리 배열 dx, dy를 선언한 후,
for문으로 반복 4번을 하여 기존 좌표에 각각을 적용하여 좌우위아래로 이동시킨 좌표를 적용한다.
그러면서도, 좌표가 2차원 배열의 바깥으로 나가면 out of bound 에러가 날 것이므로

```js
if (nextR >= 0 && nextR < N && nextC >= 0 && nextC < N)
```

이 조건문을 통해 그 경우는 이동하지 않는 것으로 처리한다.
