> https://level.goorm.io/exam/195698/%EC%97%B0%ED%95%A9/quiz/1

# 내 풀이

이번 문제도 어차피 연결된 것들을 찾아나가는 것이기 때문에 dfs나 bfs를 쓸 생각으로 접근했다.
그러다가 한 방향으로 연결된 것을 찾았을 때 그 반대로도 연결되었는지를 찾는 것이 그냥은 쉽지가 않은 것으로 생각되어
'작은 노드' 문제를 풀 때 소개되었던 인접리스트를 작성하고나서 접근하기로 하였다.

이 때 한번 또 실패가 있었는데
한번도 간선의 출발지점이 아닌 노드가 있을 때에 얘는 빈배열로 초기화가 되지 않아서, 이 노드의 간선 정보에 접근하려고할 때 에러가 가는 것이 문제였다.
근데 runtime error라고 안뜨고 fail로만 떠서 에러인지 몰랐었다.
아무튼 다음과 같은 코드로 graph를 초기화하는 코드를 작성하여 해결.

```js
for (let i = 1; i <= N; i++) {
  if (!graph[i]) {
    graph[i] = [];
  }
}
```

# 해설지

해설지에서도 내 풀이와 같은 인접 리스트로 푸는 방식이 소개되긴했는데, 이번 문제는 그렇게 했을 때
includes를 쓰게되는데 이것을 써서 구현하면 타임 아웃이 날 것이라고 소개했다.
나는 이 방법으로 해서 통과했었는데 뭐가 다른가 했더니,
해설지는 shift를 써서 bfs로 구현했었다. 그래서 이 shift만 pop으로 바꿨더니 이 해설지의 time out 걸리는 풀이 방법도 통과가 되었다.
(근데 뭔가 26,27,28을 되게 오래걸리면서 간신히 통과하는 느낌. 내 코드는 이 케이스들도 바로 통과함)

아무튼, includes가 오버헤드가 크니(O(N)), 이 문제는 인접 행렬도 같이 만들어서 양방향으로 연결되었는지 여부를 O(1)시간에 바로 찾게 하는 방식을 추천했다.

그리고 인접리스트로 구현하였을 때 나는 간선이 없는 노드도 빈배열로 초기화를 해줬는데 해설지는 다음과 같이 해결하였다.

```js
for (const nextNode of graph[currentNode] || []) {
}
```

||를 써서 해당키값이 undefined면 []이 되도록 처리한 것. 이 방법이 더 좋아 보인다.
